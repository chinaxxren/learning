{
    "sourceFile": "test.txt",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1731134797790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1732345865638,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,90 @@\n-Hello, world!\n-Hello, world!\n-ooooooo\n\\ No newline at end of file\n+This is a test content.\n+\n+一、基础优化：善用 Cargo 的内置功能\n+Rust 的构建工具 Cargo 提供了多种优化编译速度的方法：\n+\n+增量编译\n+增量编译是 Rust 默认启用的特性，通过缓存和重用中间结果减少重复计算。确保该功能开启：\n+cargo build --release\n+检查是否启用：\n+\n+RUSTC_LOG=info cargo build\n+在输出中查找incremental是否被使用。\n+\n+缓存依赖\n+通过设置 Cargo 的本地缓存目录，可以减少重复下载和编译依赖：\n+export CARGO_HOME=~/.cargo\n+避免编译未使用的依赖\n+如果项目依赖较多，启用--frozen或--locked参数确保使用固定的依赖版本，避免非必要的升级导致重新编译：\n+cargo build --locked\n+二、并行编译：释放多核性能\n+Rust 编译器rustc支持多线程编译。在多核机器上，充分利用并行能力是显著提速的关键。\n+\n+多线程优化\n+默认情况下，Cargo 已根据硬件条件自动调整并行任务数。但可以通过手动设置环境变量优化：\n+export RUSTC_THREADS=4  # 设置4线程编译\n+或在编译命令中指定：\n+\n+cargo build -j 8  # 使用8个任务并行编译\n+分阶段并行\n+为避免编译阻塞，将项目拆分为多个模块，并通过workspace实现模块的独立编译：\n+# Cargo.toml\n+[workspace]\n+members = [\"module1\", \"module2\"]\n+三、利用 LTO 和优化标志\n+链接时间优化（LTO）\n+LTO 是一种优化编译和链接效率的技术。在Cargo.toml中启用：\n+[profile.release]\n+lto = \"thin\"  # 或 \"fat\" 更高优化\n+代码生成优化\n+调整 Rust 编译器的codegen-units来减少并行度，从而改善最终二进制性能：\n+[profile.release]\n+codegen-units = 1\n+四、高效的 I/O 配置\n+编译中频繁的 I/O 操作可能成为瓶颈，以下优化能减少文件操作的时间消耗：\n+\n+使用 RAM 磁盘\n+临时将编译目录放置到内存中，加快读写速度：\n+mkdir /mnt/ramdisk\n+mount -t tmpfs -o size=4G tmpfs /mnt/ramdisk\n+export CARGO_TARGET_DIR=/mnt/ramdisk\n+优化编译缓存路径\n+默认缓存路径可能在慢速硬盘上，手动更改到 SSD 或高性能路径：\n+export CARGO_INCREMENTAL=1\n+export RUSTC_WRAPPER=/usr/bin/sccache  # 使用编译缓存工具\n+五、编译缓存工具：SCCACHE 与 MOLD\n+SCCACHE：分布式编译缓存\n+sccache是 Rust 编译的得力助手，通过缓存加速多次编译：\n+cargo install sccache\n+export RUSTC_WRAPPER=sccache\n+MOLD：极速链接器\n+替换默认链接器为mold，可显著加快链接速度：\n+cargo install mold\n+export RUSTFLAGS=\"-C linker=mold\"\n+六、完整优化配置示例\n+以下是一个包含多种加速配置的完整示例：\n+\n+# 设置 Cargo 配置路径\n+export CARGO_HOME=~/.cargo\n+export CARGO_TARGET_DIR=/mnt/ramdisk/target  # 使用 RAM 磁盘\n+\n+# 并行编译\n+export RUSTC_WRAPPER=sccache\n+export RUSTFLAGS=\"-C linker=mold\"\n+\n+# 配置 LTO 和编译优化\n+cat <<EOT > Cargo.toml\n+[profile.release]\n+lto = \"thin\"\n+codegen-units = 1\n+opt-level = 3\n+EOT\n+\n+# 启动编译\n+cargo build --release -j 8\n+七、结果对比与结论\n+优化后可观察到的编译提速效果：\n+\n+初次编译时间减少约 30%-50%。\n+增量编译时间显著缩短，仅需 10%-20% 的原始时间。\n+通过合理的配置与工具组合，你可以为 Rust 项目注入速度魔法，让开发流程更加高效流畅！\n\\ No newline at end of file\n"
                },
                {
                    "date": 1732345920380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,90 +1,1 @@\n This is a test content.\n-\n-一、基础优化：善用 Cargo 的内置功能\n-Rust 的构建工具 Cargo 提供了多种优化编译速度的方法：\n-\n-增量编译\n-增量编译是 Rust 默认启用的特性，通过缓存和重用中间结果减少重复计算。确保该功能开启：\n-cargo build --release\n-检查是否启用：\n-\n-RUSTC_LOG=info cargo build\n-在输出中查找incremental是否被使用。\n-\n-缓存依赖\n-通过设置 Cargo 的本地缓存目录，可以减少重复下载和编译依赖：\n-export CARGO_HOME=~/.cargo\n-避免编译未使用的依赖\n-如果项目依赖较多，启用--frozen或--locked参数确保使用固定的依赖版本，避免非必要的升级导致重新编译：\n-cargo build --locked\n-二、并行编译：释放多核性能\n-Rust 编译器rustc支持多线程编译。在多核机器上，充分利用并行能力是显著提速的关键。\n-\n-多线程优化\n-默认情况下，Cargo 已根据硬件条件自动调整并行任务数。但可以通过手动设置环境变量优化：\n-export RUSTC_THREADS=4  # 设置4线程编译\n-或在编译命令中指定：\n-\n-cargo build -j 8  # 使用8个任务并行编译\n-分阶段并行\n-为避免编译阻塞，将项目拆分为多个模块，并通过workspace实现模块的独立编译：\n-# Cargo.toml\n-[workspace]\n-members = [\"module1\", \"module2\"]\n-三、利用 LTO 和优化标志\n-链接时间优化（LTO）\n-LTO 是一种优化编译和链接效率的技术。在Cargo.toml中启用：\n-[profile.release]\n-lto = \"thin\"  # 或 \"fat\" 更高优化\n-代码生成优化\n-调整 Rust 编译器的codegen-units来减少并行度，从而改善最终二进制性能：\n-[profile.release]\n-codegen-units = 1\n-四、高效的 I/O 配置\n-编译中频繁的 I/O 操作可能成为瓶颈，以下优化能减少文件操作的时间消耗：\n-\n-使用 RAM 磁盘\n-临时将编译目录放置到内存中，加快读写速度：\n-mkdir /mnt/ramdisk\n-mount -t tmpfs -o size=4G tmpfs /mnt/ramdisk\n-export CARGO_TARGET_DIR=/mnt/ramdisk\n-优化编译缓存路径\n-默认缓存路径可能在慢速硬盘上，手动更改到 SSD 或高性能路径：\n-export CARGO_INCREMENTAL=1\n-export RUSTC_WRAPPER=/usr/bin/sccache  # 使用编译缓存工具\n-五、编译缓存工具：SCCACHE 与 MOLD\n-SCCACHE：分布式编译缓存\n-sccache是 Rust 编译的得力助手，通过缓存加速多次编译：\n-cargo install sccache\n-export RUSTC_WRAPPER=sccache\n-MOLD：极速链接器\n-替换默认链接器为mold，可显著加快链接速度：\n-cargo install mold\n-export RUSTFLAGS=\"-C linker=mold\"\n-六、完整优化配置示例\n-以下是一个包含多种加速配置的完整示例：\n-\n-# 设置 Cargo 配置路径\n-export CARGO_HOME=~/.cargo\n-export CARGO_TARGET_DIR=/mnt/ramdisk/target  # 使用 RAM 磁盘\n-\n-# 并行编译\n-export RUSTC_WRAPPER=sccache\n-export RUSTFLAGS=\"-C linker=mold\"\n-\n-# 配置 LTO 和编译优化\n-cat <<EOT > Cargo.toml\n-[profile.release]\n-lto = \"thin\"\n-codegen-units = 1\n-opt-level = 3\n-EOT\n-\n-# 启动编译\n-cargo build --release -j 8\n-七、结果对比与结论\n-优化后可观察到的编译提速效果：\n-\n-初次编译时间减少约 30%-50%。\n-增量编译时间显著缩短，仅需 10%-20% 的原始时间。\n-通过合理的配置与工具组合，你可以为 Rust 项目注入速度魔法，让开发流程更加高效流畅！\n\\ No newline at end of file\n"
                }
            ],
            "date": 1731134797790,
            "name": "Commit-0",
            "content": "Hello, world!\nHello, world!\nooooooo"
        }
    ]
}