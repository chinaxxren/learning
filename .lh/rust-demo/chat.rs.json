{
    "sourceFile": "rust-demo/chat.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1731131226877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1731131226877,
            "name": "Commit-0",
            "content": "use std::collections::HashMap;\nuse std::io::ErrorKind;\nuse std::sync::Arc;\n\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::TcpListener;\nuse tokio::sync::{broadcast, Mutex};\n\n#[derive(Default)]\nstruct ChatServer {\n    rooms: Mutex<HashMap<String, broadcast::Sender<String>>>,\n}\n\nimpl ChatServer {\n    async fn join_room(&self, room_name: &str, user_name: &str, mut socket: TcpStream) {\n        let (tx, mut rx) = broadcast::channel(10);\n        {\n            let mut rooms = self.rooms.lock().await;\n            rooms.entry(room_name.to_string()).or_insert_with(|| {\n                println!(\"Creating room: {}\", room_name);\n                tx.clone()\n            });\n            let room_tx = rooms.get_mut(room_name).unwrap();\n            let msg = format!(\"{} joined the room.\", user_name);\n            let _ = room_tx.send(msg);\n            let mut rx = room_tx.subscribe();\n            tokio::spawn(async move {\n                loop {\n                    match rx.recv().await {\n                        Ok(msg) => {\n                            if let Err(e) = socket.write_all(msg.as_bytes()).await {\n                                println!(\"Error sending message: {}\", e);\n                                break;\n                            }\n                        }\n                        Err(broadcast::error::RecvError::Lagged(lag)) => {\n                            println!(\"Lagged behind on {} messages\", lag);\n                        }\n                        Err(broadcast::error::RecvError::Closed) => {\n                            println!(\"Channel closed\");\n                            break;\n                        }\n                    }\n                }\n            });\n        }\n\n        loop {\n            let mut buf = [0; 1024];\n            match socket.read(&mut buf).await {\n                Ok(n) if n == 0 => break,\n                Ok(n) => {\n                    let msg = format!(\"{}: {}\", user_name, String::from_utf8_lossy(&buf[..n]));\n                    if let Err(_) = tx.send(msg) {\n                        println!(\"Error sending message to room\");\n                        break;\n                    }\n                }\n                Err(ref e) if e.kind() == ErrorKind::WouldBlock => {\n                    continue;\n                }\n                Err(e) => {\n                    println!(\"Error reading from socket: {:?}\", e);\n                    break;\n                }\n            }\n        }\n        self.leave_room(room_name, user_name).await;\n    }\n\n    async fn leave_room(&self, room_name: &str, user_name: &str) {\n        let mut rooms = self.rooms.lock().await;\n        if let Some(tx) = rooms.get_mut(room_name) {\n            let msg = format!(\"{} left the room.\", user_name);\n            let _ = tx.send(msg);\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").await.unwrap();\n    println!(\"Server listening on {}\", listener.local_addr().unwrap());\n\n    let chat_server = Arc::new(ChatServer::default());\n\n    loop {\n        let (socket, addr) = listener.accept().await.unwrap();\n        println!(\"New client connected: {}\", addr);\n\n        let chat_server = chat_server.clone();\n        tokio::spawn(async move {\n            let mut buf = [0; 1024];\n            if let Ok(n) = socket.read(&mut buf).await {\n                let msg = String::from_utf8_lossy(&buf[..n]);\n                let parts: Vec<&str> = msg.splitn(2, ':').collect();\n                if parts.len() == 2 {\n                    let room_name = parts[0].trim();\n                    let user_name = parts[1].trim();\n                    chat_server.join_room(room_name, user_name, socket).await;\n                }\n            }\n        });\n    }\n}"
        }
    ]
}